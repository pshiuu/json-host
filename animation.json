{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"sdf_shape","speed":0.32,"trackMouseMove":0,"mouseMomentum":0.88,"trackMouse":0,"parentLayer":"c8b506a0-ba28-415a-be0a-0f936215bfc3","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.141592653; const float PI2 = 6.283185306; const float DISP_STEPS = 12.; const vec3 viewDir = vec3(0,0, -4.25);const mat3 ROT_Y_90 = mat3( 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0 );const mat3 ROT_Z_90 = mat3( 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 );const mat3 ROT_X_90 = mat3( 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0 );float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }mat3 rotY(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c); }mat3 rotX(float ang) { float c = cos(ang), s = sin(ang); return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); }mat3 rotZ(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0); }vec3 twistY(vec3 p, float amount) { float c = cos(amount * p.y); float s = sin(amount * p.y); mat2 m = mat2(c, -s, s, c); return vec3(m * p.xz, p.y); }vec3 twistX(vec3 p, float amount) { float c = cos(amount * p.x); float s = sin(amount * p.x); mat2 m = mat2(c, -s, s, c); return vec3(p.x, m * p.yz); }float sphere(vec3 p, float r) { return length(p) - r; }float sdStar5(vec2 p, float r, float rf) { const vec2 k1 = vec2(0.809016994375, -0.587785252292); const vec2 k2 = vec2(-k1.x,k1.y); p.x = abs(p.x); p -= 2.0*max(dot(k1,p),0.0)*k1; p -= 2.0*max(dot(k2,p),0.0)*k2; p.x = abs(p.x); p.y -= r; vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1); float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r ); return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y); }vec3 stripePattern(vec3 x) { x *= 5.; x *= rotY(radians(45.)); x *= rotX(radians(45.)); float dot = sin(x.x); return vec3(dot * normalize(dot)); }vec3 getSurfaceTexture(vec3 coord, float frequency) { return stripePattern(coord * frequency); }vec3 getRepeat(vec3 p) { float spacing = (0.50 + 0.00 * 0.38) * 8.; return p; }vec3 getThreeDRepeat(vec3 p) { float spacing = (0.50 + 0.00 * 0.38) * 8.; return p; }vec3 getAdjustedP(vec3 p) { float scaleFactor = 0.43 < 1e-7 ? 1e7 : 1.0/0.43; vec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0, 0);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.00 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.00); vec2 axis = vec2(-1. * vec3(0.5, 0.5, 0.5).y - 1. + mousePos.y/PI, vec3(0.5, 0.5, 0.5).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02; float timeX = vec3(0, 1, 0).x * baseTime; float timeY = vec3(0, 1, 0).y * baseTime; float timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI); mat3 rotXMat = rotX(axis.x * PI); mat3 rotZMat = rotZ(vec3(0.5, 0.5, 0.5).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat; mat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP; adjustedP = combinedAnimation * adjustedP; adjustedP = getThreeDRepeat(adjustedP); adjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y))); adjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x))); adjustedP += getSurfaceTexture(adjustedP, 20. * 0.40) * 0.025 * 0.06;return adjustedP; }float getMergedSDF(vec3 p) { p = getAdjustedP(p); return sphere(p, 1.0); }float fresnel(vec3 eyeVector, vec3 worldNormal, float power) { float fresnelFactor = 1.0 - abs(dot(eyeVector, worldNormal)); return pow(fresnelFactor, power); }vec3 noFrostOrDispersion(vec3 rd, vec3 normal) { float ior = 1.0 / (1.0 + 0.00 * 0.25); vec3 refractedRay = refract(rd, normal, ior); return texture(uTexture, vTextureCoord - refractedRay.xy).rgb; }vec3 frostOrDispersion(vec3 rd, vec3 normal) { vec3 refractionColor = vec3(0); float iorBase = 1. + 0.00 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 1.00 * 1.2;for(float i = 0.; i < DISP_STEPS; i++) { float step = i / DISP_STEPS; vec3 disp = step * dispCoefficients; vec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r); vec3 refractedRayG = refract(rd, normal, ior.g); vec3 refractedRayB = refract(rd, normal, ior.b);vec2 rayDirOffset = vec2( rand(rd.xy + step) * 2. - 1., rand(rd.xy + step * 2.) * 2. - 1. ) * mix(1., rand(rd.xy + step * 3.), 0.8); refractedRayR.xy += rayDirOffset * (0.1 + disp.r) * 0.13; refractedRayG.xy += rayDirOffset * (0.1 + disp.g) * 0.13; refractedRayB.xy += rayDirOffset * (0.1 + disp.b) * 0.13;refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r; refractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g; refractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b; }return clamp(refractionColor / DISP_STEPS, 0.0, 1.0); }vec3 calculateNormal(vec3 p, float eps) { float dx = getMergedSDF(p + vec3(eps, 0.0, 0.0)) - getMergedSDF(p - vec3(eps, 0.0, 0.0)); float dy = getMergedSDF(p + vec3(0.0, eps, 0.0)) - getMergedSDF(p - vec3(0.0, eps, 0.0)); float dz = getMergedSDF(p + vec3(0.0, 0.0, eps)) - getMergedSDF(p - vec3(0.0, 0.0, eps)); return normalize(vec3(dx, dy, dz)); }vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal);return frostOrDispersion(rd, normal); return noFrostOrDispersion(rd, normal); }float scene(vec3 p) { return max(0., getMergedSDF(p) - 0.00) * max(0.43, 0.0000000001); }float getPixelSize() { return 1.0 / min(uResolution.x, uResolution.y); }const int STEPS = 128; const float MAX_DISTANCE = 40.0;vec4 rayMarch(vec3 ro, vec3 rd, float min_dist) { float traveled = 0.; vec3 entryPoint = vec3(0.0); vec3 entryNormal = vec3(0.0); float partialAlpha = 0.0;for (int i = 0; i < STEPS; ++i) { vec3 currentPos = ro + rd * traveled; float distance = scene(currentPos); float pixelSize = getPixelSize();if (distance < pixelSize * 2.) { partialAlpha = 0.5; entryPoint = currentPos; entryNormal = calculateNormal(entryPoint, pixelSize); }if (distance < pixelSize) { partialAlpha = 1.; entryPoint = currentPos; entryNormal = calculateNormal(entryPoint, pixelSize); break; }if(traveled < 0.05) { traveled += distance * 0.9; } else { traveled += distance; } if (traveled > MAX_DISTANCE) break; }if (partialAlpha == 0.0) { return texture(uTexture, vTextureCoord); }vec4 bg = texture(uTexture, vTextureCoord);vec3 samplePosition = mix(rd, entryPoint, 0.00); vec3 refractionColor = sampleTexture(samplePosition, entryNormal);vec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.5, 0.48), vec3(0.25, 0.25, -3).z); vec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir); vec3 lightColor = mix(vec3(1), vec3(1, 1, 1), 1. - 0.00); vec3 fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.00 * vec3(1, 1, 1); vec3 halfwayDir = normalize(lightDir + rd); float specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 0.36 + 0.01); vec3 specularEffect = specFactor * 0.36 * lightColor; vec3 combinedEffects = fresnelEffect + specularEffect; vec3 finalColor = mix(refractionColor, vec3(1, 1, 1) * lightAndShadow, 0.00); finalColor += combinedEffects; vec4 outputColor = mix(bg, vec4(finalColor, 1.), partialAlpha);return outputColor; }out vec4 fragColor;void main() { vec2 pos = vec2(0.5, 0.48) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 uv = vTextureCoord - pos; float fovFactor = tan(radians(20.) * 0.5); vec3 rd = vec3(uv * fovFactor, 0.5);float mdist = 0.004; vec4 col = rayMarch(viewDir, rd, mdist); float dither = (rand(vTextureCoord.xy) - 0.5) / 255.0; col += dither; fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[{"props":{"width":[30,-258],"height":[4,283],"translateX":457,"translateY":89,"mouseMomentum":0.47,"rotation":0,"trackMouse":0,"fitToCanvas":0,"strokeWidth":0,"type":"circle"},"min":992,"name":"Desktop","max":null},{"max":991,"name":"Tablet","props":{"translateX":479,"translateY":52.5,"width":[-19.548387096774206,-258],"height":[52,283]},"min":576},{"min":0,"name":"Mobile","max":575,"props":{"width":[-47.419354838709694,-258],"height":[79,283],"translateX":493,"translateY":39}}],"visible":true,"locked":false,"aspectRatio":1.5470008952551477,"layerName":"","isElement":true,"opacity":1,"displace":0,"trackMouse":0,"mouseMomentum":0.47,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0.23,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","borderRadius":0,"coords":[[30,4],[-258,4],[-258,283],[30,283]],"effects":["c8b506a0-ba28-415a-be0a-0f936215bfc3","e67a7c71-c26c-4a23-be67-027ddbd44aa9","e20f8f3b-5e2b-4b8e-a1f4-4a9db4aa62ec"],"fill":["#F2B25C","#EA3363","#EA94E1","#204FD9"],"fitToCanvas":false,"gradientAngle":0,"gradientType":"linear","rotation":0,"translateX":457,"translateY":89,"type":"circle","stroke":["#000000"],"strokeWidth":0,"numSides":3,"width":[30,-258],"height":[4,283],"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; uniform int uSampleBg;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.23); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = perspectiveUV(uv) - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"noise","speed":0.53,"trackMouse":1,"mouseMomentum":1,"parentLayer":"e67a7c71-c26c-4a23-be67-027ddbd44aa9","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }vec4 permute(vec4 t) { return t * (t * 34.0 + 133.0); }vec3 grad(float hash) { vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0; vec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0)); float index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0; cuboct.y *= 1.0 - index1; cuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0); vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad; } vec4 bccNoiseDerivativesPart(vec3 X) { vec3 b = floor(X); vec4 i4 = vec4(X - b, 2.5); vec3 v1 = b + floor(dot(i4, vec4(.25))); vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35))); vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35))); vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35))); vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0)); hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0)); hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0); vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4; vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0); vec4 aa = a * a; vec4 aaaa = aa * aa; vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y); vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w); vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4)); vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) + mat4x3(g1, g2, g3, g4) * aaaa; return vec4(derivative, dot(aaaa, extrapolations)); } vec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) { mat3 orthonormalMap = mat3( 0.788675134594813, -0.211324865405187, -0.577350269189626, -0.211324865405187, 0.788675134594813, -0.577350269189626, 0.577350269189626, 0.577350269189626, 0.577350269189626); X = orthonormalMap * X; vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5); return vec4(result.xyz * orthonormalMap, result.w); }out vec4 fragColor;const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec2 get2sNoise(vec2 uv, vec2 textureCoord) { vec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(uv * vec2(0.50, 1. - 0.50) * 0.7, 0.00 + uTime*0.02)); vec2 offset = noise.xy/7. + 0.5; return mix(textureCoord, offset, 0.26); }vec2 getNoiseOffset(vec2 uv, vec2 textureCoord) { return get2sNoise(uv, textureCoord); }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.45049504950495056, 0.4846759675967597) + mix(vec2(0), (uMousePos-0.5), 1.00); vec2 pos = vec2(0.45049504950495056, 0.4846759675967597); vec2 st = (uv - pos) * vec2(aspectRatio, 1); st *= 12. * 0.62; st = rot(0.04 * -1. * 2.0 * PI) * st;vec2 noise = getNoiseOffset(st, uv); float dist = ease(3, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 0.68)));if (0 == 1) { dist = max(0., (0.5 - dist)); }uv = mix(uv, noise, dist); vec4 color = texture(uTexture, uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"grain","speed":0.41,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; } const float PHI = 1.61803398874989484820459; float gold_noise(in vec2 xy, in float seed) { return fract(tan(distance(xy*PHI, xy)*seed)*xy.x); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);if(color.a == 0.) { fragColor = vec4(0); return; }vec2 st = uv; vec3 grainRGB = vec3(0);st *= uResolution;float delta = fract((floor(uTime)/20.));if(0 == 1) { grainRGB = vec3( gold_noise(st, delta + 1.), gold_noise(st, delta + 2.), gold_noise(st, delta + 3.) ); } else { grainRGB = vec3(gold_noise(st, delta + 1.)); } if(1 > 0) { color.rgb = mix(color.rgb, blend(1, grainRGB, color.rgb), 0.10); } fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"mouse","parentLayer":"e20f8f3b-5e2b-4b8e-a1f4-4a9db4aa62ec","animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;const float PI = 3.1415926; const float ITERATIONS = 24.0;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec4 defaultTrail(vec2 uv, vec2 mouseDir) { vec4 color = vec4(0); vec2 distorted = mouseDir * 0.4; color = texture(uTexture, uv - distorted); color.rgb = chromatic_aberration(color.rgb, uv - distorted, distorted * 0.25 * 0.12); return color; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float aspectRatio = uResolution.x / uResolution.y;return defaultTrail(uv, mouseDir); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.12 * 2.0); vec2 direction = angleToDir(angle); vec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, strength);fragColor = color; }","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 uv = vTextureCoord; vec2 correctedUv = uv * vec2(aspectRatio, 1.0);vec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0); float dist = length(dir); dir = normalize(dir);float rad = 0.22 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI;float t = clamp(dot(correctedUv - uPreviousMousePos * vec2(aspectRatio, 1.0), dir) / dist, 0.0, 1.0); vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * vec2(aspectRatio, 1.0); float distanceToLine = distance(correctedUv, closestPoint);float s = smoothstep(rad, rad * 0.37, distanceToLine);vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 mouseColor = hsv2rgb(color);vec3 lastFrameColor = texture(uPingPongTexture, mix(uv, uv / 1.03 + 0.015, 0.00)).rgb; vec3 draw = mix(lastFrameColor, mouseColor, min(1.0, dist * s));fragColor = vec4(draw * pow(0.50, 0.1), 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{}}}],"options":{"name":"Copy of Hero section","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.3.2","id":"4HGo5iIp1kvMCrenGwAV"}
