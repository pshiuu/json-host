{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos; vec3 getColor(int index) { switch(index) { case 0: return vec3(1, 1, 1); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(1, 1, 1); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"waterRipple","usesPingPong":true,"speed":0.75,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uPingPongTexture;const float PI = 3.1415926; const float ITERATIONS = 24.0;out vec4 fragColor;vec3 calculateNormal(sampler2D tex, vec2 uv) { float stengthScale = mix(3., 7., 0.6000); float stepScale = mix(1., 3., 0.6000); float strength = mix(1., stengthScale, 0.5000); float stepSize = mix(1., stepScale, 0.5000); float step = stepSize / 1080.; float left = texture(tex, uv + vec2(-step, 0.0)).r; float right = texture(tex, uv + vec2(step, 0.0)).r; float top = texture(tex, uv + vec2(0.0, -step)).r; float bottom = texture(tex, uv + vec2(0.0, step)).r; vec3 normal; normal.x = (right - left) * strength; normal.y = -(bottom - top) * strength; normal.z = -1.0; return normalize(normal); }vec4 drawRipple(vec2 uv) { vec2 scaled = mix(uv, (uv - 0.5) * 0.5 + 0.5, 0.6000); vec3 normal = calculateNormal(uPingPongTexture, scaled); return vec4(normal, 1.); }const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0); const vec3 VIEW_POS = vec3(0.0, 0.0, 2.0); const float SPECULAR = 2.4; const float SHININESS = 128.0;vec4 getColor(vec2 uv) { return drawRipple(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color; }","#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture;const float PI = 3.1415926; const float ITERATIONS = 24.0;float getGaussianWeight(int index) { switch(index) { case 0: return 0.7978845608028654; case 1: return 0.795118932516684; case 2: return 0.7868794322038799; case 3: return 0.7733362336056986; case 4: return 0.7547664553859864; case 5: return 0.7315447328280048; case 6: return 0.704130653528599; case 7: return 0.6730536454899063; case 8: return 0.6388960110447045; case 9: return 0.6022748643096089; case 10: return 0.5638237508206051; case 11: return 0.5241747061566029; case 12: return 0.48394144903828673; case 13: return 0.443704309411472; case 14: return 0.40399737110811773; case 15: return 0.36529817077804383; case 16: return 0.3280201493519873; case 17: return 0.29250790855907144; case 18: return 0.2590351913317835; case 19: return 0.2278053882403838; case 20: return 0.19895427758549736; case 21: return 0.17255463765302306; case 22: return 0.1486223271179862; case 23: return 0.12712341303392466; default: return 0.0; } }out vec4 fragColor;vec4 blur(vec2 uv, vec2 dir) { vec4 color = vec4(0.0); float total_weight = 0.0; vec4 center = texture(uTexture, uv); float center_weight = getGaussianWeight(0); color += center * center_weight; total_weight += center_weight; for (int i = 1; i <= 11; i++) { float weight = getGaussianWeight(i); float offset = mix(0.005, 0.015, 0.2500) * float(i)/11.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0); const vec3 VIEW_POS = vec3(0.0, 0.0, 2.0); const float SPECULAR = 2.4; const float SHININESS = 128.0;vec4 getColor(vec2 uv) { return blur(uv, vec2(1, 0)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color; }","#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture;const float PI = 3.1415926; const float ITERATIONS = 24.0;float getGaussianWeight(int index) { switch(index) { case 0: return 0.7978845608028654; case 1: return 0.795118932516684; case 2: return 0.7868794322038799; case 3: return 0.7733362336056986; case 4: return 0.7547664553859864; case 5: return 0.7315447328280048; case 6: return 0.704130653528599; case 7: return 0.6730536454899063; case 8: return 0.6388960110447045; case 9: return 0.6022748643096089; case 10: return 0.5638237508206051; case 11: return 0.5241747061566029; case 12: return 0.48394144903828673; case 13: return 0.443704309411472; case 14: return 0.40399737110811773; case 15: return 0.36529817077804383; case 16: return 0.3280201493519873; case 17: return 0.29250790855907144; case 18: return 0.2590351913317835; case 19: return 0.2278053882403838; case 20: return 0.19895427758549736; case 21: return 0.17255463765302306; case 22: return 0.1486223271179862; case 23: return 0.12712341303392466; default: return 0.0; } }out vec4 fragColor;vec4 blur(vec2 uv, vec2 dir) { vec4 color = vec4(0.0); float total_weight = 0.0; vec4 center = texture(uTexture, uv); float center_weight = getGaussianWeight(0); color += center * center_weight; total_weight += center_weight; for (int i = 1; i <= 11; i++) { float weight = getGaussianWeight(i); float offset = mix(0.005, 0.015, 0.2500) * float(i)/11.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0); const vec3 VIEW_POS = vec3(0.0, 0.0, 2.0); const float SPECULAR = 2.4; const float SHININESS = 128.0;vec4 getColor(vec2 uv) { return blur(uv, vec2(0, 1)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color; }","#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uBgTexture;const float PI = 3.1415926; const float ITERATIONS = 24.0;out vec4 fragColor;vec3 chromatic_aberration(vec3 color, vec2 uv) { vec2 offset = (uv - vTextureCoord) * (0.2500 * 0.2); vec4 left = texture(uBgTexture, uv - offset); vec4 right = texture(uBgTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 calculateRefraction(vec3 normal, float ior) { vec3 I = vec3(0.0, 0.0, 1.0); float ratio = 1.0 / ior; vec3 refracted = refract(I, normal, ratio); float refractionScale = mix(0.2, 0.4, 0.6000); float refractionAmount = mix(0.01, refractionScale, 0.5000); return refracted.xy * refractionAmount; }const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0); const vec3 VIEW_POS = vec3(0.0, 0.0, 2.0); const float SPECULAR = 2.4; const float SHININESS = 128.0;vec3 calculateLighting(vec3 normal, vec2 uv) { vec3 N = normal; vec3 worldPos = vec3(uv * 2.0 - 1.0, 0.0); vec3 lightDir = normalize(LIGHT_POS - worldPos); vec3 viewDir = normalize(VIEW_POS - worldPos); vec3 reflectDir = reflect(-lightDir, N); float diff = max(dot(N, lightDir), 0.0); vec3 diffuse = vec3(diff); float spec = pow(max(dot(viewDir, reflectDir), 0.0), SHININESS); vec3 specular = vec3(spec * SPECULAR); return diffuse + specular; }vec4 getRipple(vec2 uv) { vec3 normal = texture(uTexture, uv).rgb; vec2 refractionOffset = calculateRefraction(normal, 1.333); vec2 refractedUv = uv + refractionOffset; vec3 refractedNormal = texture(uTexture, refractedUv).rgb;vec4 refractedColor = texture(uBgTexture, refractedUv); refractedColor.rgb = chromatic_aberration(refractedColor.rgb, refractedUv);vec3 caustics = calculateLighting(refractedNormal, refractedUv); float causticsShadow = dot(normal, normalize(vec3(2.0, -2.0, 3.0) - vec3(uv * 2.0 - 1.0, 0.0))) + 1.; float shadowFactor = causticsShadow; vec3 lightingFactor = caustics;shadowFactor = mix(1., shadowFactor, 0.5000); lightingFactor = mix(vec3(0), lightingFactor * vec3(1, 1, 1), 0.5000); vec4 finalColor = vec4(refractedColor.rgb - vec3(1.-shadowFactor) * vec3(1, 1, 1) + lightingFactor, refractedColor.a); return finalColor; }vec4 getColor(vec2 uv) { return getRipple(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color; }","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;void main() { vec2 aspect = vec2(uResolution.x/uResolution.y, 1); vec2 texelSize = (1.0 / (vec2(1080) * aspect)) * mix(1., 8., 0.7500); vec2 vUv = vTextureCoord; vec2 mPos = mix(uMousePos, (uMousePos - 0.5) * 0.5 + 0.5, 0.6000); vec2 pmPos = mix(uPreviousMousePos, (uPreviousMousePos - 0.5) * 0.5 + 0.5, 0.6000);float waveSpeed = 1.; float damping = mix(0.8, 0.999, 0.7500); float velocityDamping = damping; float heightDamping = damping; float time = 0.5;vec4 data = texture(uPingPongTexture, vUv); float height = data.r; float velocity = data.g;float laplacian = 0.0; float totalWeight = 0.0; float scaleDiff = 0.6000 * 0.25; vec2 clampRegionMin = vec2(0.6000 * 0.5 - scaleDiff); vec2 clampRegionMax = vec2(1.0 - 0.6000 * 0.5 + scaleDiff); vec2 offset = vec2(texelSize.x, 0.0); vec2 neighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax); float weight = 1.0 - length(offset) / (length(texelSize) * 2.0); laplacian += texture(uPingPongTexture, neighborUv).r * weight; totalWeight += weight; offset = vec2(-texelSize.x, 0.0); neighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax); weight = 1.0 - length(offset) / (length(texelSize) * 2.0); laplacian += texture(uPingPongTexture, neighborUv).r * weight; totalWeight += weight; offset = vec2(0.0, texelSize.y); neighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax); weight = 1.0 - length(offset) / (length(texelSize) * 2.0); laplacian += texture(uPingPongTexture, neighborUv).r * weight; totalWeight += weight; offset = vec2(0.0, -texelSize.y); neighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax); weight = 1.0 - length(offset) / (length(texelSize) * 2.0); laplacian += texture(uPingPongTexture, neighborUv).r * weight; totalWeight += weight;float avgNeighbors = laplacian / totalWeight; laplacian = avgNeighbors - height;velocity += waveSpeed * waveSpeed * laplacian; velocity *= velocityDamping; height += velocity; height *= heightDamping;float mouseSpeed = distance(mPos * aspect, pmPos * aspect); float dist = distance(vUv * aspect, mPos * aspect); float radius = 0.025; if (dist < radius && mouseSpeed > 0.0001) { float drop = cos(dist / radius * PI * time); float intensity = mouseSpeed * 20.; height += drop * intensity; }fragColor = vec4(height, velocity, 0.0, 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":true},{"prop":"pass","value":2,"downSample":true},{"prop":"pass","value":3,"includeBg":true}]}},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1.6,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0,"anchorPoint":"topLeft","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":1,"maskDepth":"2","dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":140.00000000000006,"widthMode":"fixed","height":121.00000000000006,"heightMode":"fixed","left":0.1861111111111111,"leftMode":"relative","top":0.39666666666666667,"topMode":"relative","rotation":0,"pos":{"type":"Vec2","_x":0.5,"_y":0.5},"borderRadius":0,"gradientAngle":0,"strokeWidth":0,"coords":[[0,0],[140.00000000000006,0],[140.00000000000006,121.00000000000006],[0,121.00000000000006]],"fill":["#CEFFDD"],"fitToCanvas":false,"gradientType":"linear","type":"rectangle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.0000);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}}},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1.6,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0,"anchorPoint":"topLeft","mouseMomentum":1,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0.38,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":225,"widthMode":"fixed","height":154,"heightMode":"fixed","left":0.7173611111111111,"leftMode":"relative","top":0.6277777777777778,"topMode":"relative","rotation":0,"pos":{"type":"Vec2","_x":0.5,"_y":0.5},"borderRadius":0,"gradientAngle":0,"strokeWidth":0,"coords":[[0,0],[225,0],[225,154],[0,154]],"fill":["#CEFFDD"],"fitToCanvas":false,"gradientType":"linear","type":"rectangle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; uniform int uSampleBg;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.3800); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = perspectiveUV(uv) - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.0000);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}}},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1.6,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0,"anchorPoint":"topLeft","mouseMomentum":1,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0.38,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":361,"widthMode":"fixed","height":250,"heightMode":"fixed","left":0.32430555555555557,"leftMode":"relative","top":0.14333333333333334,"topMode":"relative","rotation":0,"pos":{"type":"Vec2","_x":0.5,"_y":0.5},"borderRadius":0,"gradientAngle":0,"strokeWidth":0,"coords":[[0,0],[361,0],[361,250],[0,250]],"fill":["#CEFFDD"],"fitToCanvas":false,"gradientType":"linear","type":"rectangle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; uniform int uSampleBg;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.3800); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = perspectiveUV(uv) - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.0000);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}}},{"breakpoints":[],"visible":true,"locked":true,"aspectRatio":1.6,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0,"anchorPoint":"topLeft","mouseMomentum":1,"blendMode":"OVERLAY","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0.38,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":312,"widthMode":"fixed","height":219,"heightMode":"fixed","left":0.1729166666666667,"leftMode":"relative","top":0.6344444444444444,"topMode":"relative","rotation":0,"pos":{"type":"Vec2","_x":0.5,"_y":0.5},"borderRadius":0,"gradientAngle":0,"strokeWidth":0,"coords":[[0,0],[312,0],[312,219],[0,219]],"fill":["#E8F2FF"],"fitToCanvas":false,"gradientType":"linear","type":"rectangle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uPreviousLayerTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z))); }const float STEPS = 24.0; const float PI = 3.1415926;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.3800); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000); uv = perspectiveUV(uv) - pos; vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);if (0.0000 == 1.00) { if(0 == 2) { background *= (1. - color.a); color = background; } else { background *= color.a; color.rgb = background.rgb; color.rgb = 0.0000 > 0. ? mix(vec3(0, 0, 0), color.rgb, color.a) : color.rgb; color.a = min(1., color.a + 0.0000); if(0 == 1) { vec4 previousLayer = texture(uPreviousLayerTexture, vTextureCoord); color = mix(previousLayer, color/max(color.a, 0.0001), color.a * 1.0000); } } fragColor = color; return; }if (5 > 0) { vec3 unpremultColor = color.rgb / max(color.a, 0.0001); vec3 blendedColor = blend(5, unpremultColor, background.rgb); color = vec4(blendedColor, 1.0) * (color.a * 1.0000); color = color + background * (1.0 - color.a); } else { color = mix(background, color + background * (1.0 - color.a), 1.0000); }fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"noise","usesPingPong":false,"speed":0.01,"trackMouse":0,"mouseMomentum":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }vec4 permute(vec4 t) { return t * (t * 34.0 + 133.0); }vec3 grad(float hash) { vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0; vec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0)); float index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0; cuboct.y *= 1.0 - index1; cuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0); vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad; } vec4 bccNoiseDerivativesPart(vec3 X) { vec3 b = floor(X); vec4 i4 = vec4(X - b, 2.5); vec3 v1 = b + floor(dot(i4, vec4(.25))); vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35))); vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35))); vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35))); vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0)); hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0)); hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0); vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4; vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0); vec4 aa = a * a; vec4 aaaa = aa * aa; vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y); vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w); vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4)); vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) + mat4x3(g1, g2, g3, g4) * aaaa; return vec4(derivative, dot(aaaa, extrapolations)); } vec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) { mat3 orthonormalMap = mat3( 0.788675134594813, -0.211324865405187, -0.577350269189626, -0.211324865405187, 0.788675134594813, -0.577350269189626, 0.577350269189626, 0.577350269189626, 0.577350269189626); X = orthonormalMap * X; vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5); return vec4(result.xyz * orthonormalMap, result.w); }out vec4 fragColor;const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec2 get2sNoise(vec2 uv, vec2 textureCoord) { vec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(uv * vec2(0.5000, 1. - 0.5000) * 0.7, 0.0000 + uTime*0.02)); vec2 offset = noise.xy/7. + 0.5; return mix(textureCoord, offset, 0.6800); }vec2 getNoiseOffset(vec2 uv, vec2 textureCoord) { return get2sNoise(uv, textureCoord); }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); vec2 st = (uv - pos) * vec2(aspectRatio, 1); st *= 12. * 0.1200; st = rot(0.0000 * -1. * 2.0 * PI) * st;vec2 noise = getNoiseOffset(st, uv); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); }uv = mix(uv, noise, dist); vec4 color = texture(uTexture, uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"bulge","usesPingPong":false,"trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord; in float zPos;uniform sampler2D uTexture;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor; void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);float intensity = 0.7500 * 0.5;float rad = (0.5000 - 0.25) * -2. * 3.14159; vec2 rotatedLightPosition = vec2(cos(rad), sin(rad)); vec3 lightPosition = vec3(vec2(0.5) * rotatedLightPosition * 2., 1.0);float diff = max(dot(normalize(vVertexPosition), lightPosition), 0.0); color.rgb += (diff * intensity - intensity);float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;out vec2 vTextureCoord; out vec3 vVertexPosition; out float zPos;uniform sampler2D uTexture;uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }float bezier(float t) { return ease(3, t); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 bulge(vec3 pos) { vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1); vec2 mousePosAdjusted = mix((vec2(0.5, 0.5) - 0.5) * 2., (uMousePos - 0.5) * 2., 0.0000); vec2 skew = vec2(0.5000, 1.-0.5000); mat2 rotation = rot(0.5000 * 2. * 3.14159);float dist = distance(pos.xy * aspectRatio * rotation * skew, mousePosAdjusted * aspectRatio * rotation * skew);float t = max(0., 1. - dist/0.5000); float bulge = bezier(t) * (0.7500 - 0.5);float luma = dot(texture(uTexture, (pos.xy + 1.) * 0.5).rgb, vec3(0.299, 0.587, 0.114));bulge += luma * bezier(t) * 0.0000; bulge = min(1., bulge);pos.xy += bulge * pos.xy; pos.z -= bulge; return pos; }void main() { vec3 pos = bulge(aVertexPosition); vec3 pos_dx = bulge(aVertexPosition + vec3(0.01, 0.0, 0.0)); vec3 pos_dy = bulge(aVertexPosition + vec3(0.0, 0.01, 0.0)); vec3 dx = pos_dx - pos; vec3 dy = pos_dy - pos; vec3 normal = normalize(cross(dx, dy));vVertexPosition = normal;zPos = pos.z;gl_Position = vec4(pos, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":true,"uniforms":{},"isBackground":false,"heightSegments":500,"widthSegments":500}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"flowField","usesPingPong":false,"speed":0.01,"trackMouse":0,"mouseMomentum":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787)); p3 += dot(p3, p3.yxz + 19.19); return -1.0 + 2.0 * fract(vec3( (p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x )); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0))); float n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0))); float n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0))); float n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0))); float n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0))); float n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0))); float n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0))); float n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x); float nx01 = mix(n001, n101, w.x); float nx10 = mix(n010, n110, w.x); float nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y); float nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz; }const float MAX_ITERATIONS = 16.; vec2 flow (in vec2 st) { float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(st * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));float sprd = (0.5000 + 0.01) / ((aspectRatio + 1.) / 2.); float amt = 0.5000 * 0.01 * dist; if(amt <= 0.) { return st; }for (float i = 0.; i < MAX_ITERATIONS; i++) { vec2 scaled = (st-0.5) * vec2(aspectRatio, 1) + (1. - pos); float perlin = perlin_noise(vec3((scaled-0.5) * (5. * sprd), 0.0000*5. + uTime/60.))-0.5; float ang = (perlin * (360. * (0.5000 * 6.))) * 3.1415926 / 180.; st += vec2(cos(ang), sin(ang)) * amt; st = clamp(st, 0., 1.); }return st; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, mix(uv, flow(uv), 1.0000)); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"progressiveBlur","usesPingPong":false,"trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 directionalBlur(vec2 uv, bool isVertical) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);float amt = 6.;vec2 st = uv * rot(0.0000 * 2. * PI); pos *= rot(0.0000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float amount = 0.4300 * amt * dist * jawn;if (amount < 0.0001) { return texture(uTexture, uv); } color += texture(uTexture, uv) * getGaussianWeight(0);vec2 direction = isVertical ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; vec2 offset = vec2(x * 0.001) * direction; color += texture(uTexture, uv + offset) * getGaussianWeight(i); }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither;return color; }vec4 getColor(vec2 uv) { return directionalBlur(uv, false); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 directionalBlur(vec2 uv, bool isVertical) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);float amt = 6.;vec2 st = uv * rot(0.0000 * 2. * PI); pos *= rot(0.0000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float amount = 0.4300 * amt * dist * jawn;if (amount < 0.0001) { return texture(uTexture, uv); } color += texture(uTexture, uv) * getGaussianWeight(0);vec2 direction = isVertical ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; vec2 offset = vec2(x * 0.001) * direction; color += texture(uTexture, uv + offset) * getGaussianWeight(i); }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither;return color; }vec4 getColor(vec2 uv) { return directionalBlur(uv, false); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 directionalBlur(vec2 uv, bool isVertical) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);float amt = 6.;vec2 st = uv * rot(0.0000 * 2. * PI); pos *= rot(0.0000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float amount = 0.4300 * amt * dist * jawn;if (amount < 0.0001) { return texture(uTexture, uv); } color += texture(uTexture, uv) * getGaussianWeight(0);vec2 direction = isVertical ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; vec2 offset = vec2(x * 0.001) * direction; color += texture(uTexture, uv + offset) * getGaussianWeight(i); }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither;return color; }vec4 getColor(vec2 uv) { return directionalBlur(uv, true); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 finalBlur(vec2 uv) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);float amt = 11.;vec2 st = uv * rot(0.0000 * 2. * PI); pos *= rot(0.0000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float amount = 0.4300 * amt * dist * jawn;if (amount < 0.0001) { return texture(uTexture, uv); } color += texture(uTexture, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(uTexture, uv + vec2(x * 0.001, 0)) * getGaussianWeight(i) * 0.5; color += texture(uTexture, uv + vec2(0, x * 0.001) * vec2(1, uResolution.x/uResolution.y)) * getGaussianWeight(i) * 0.5; }return color; }vec4 getColor(vec2 uv) { return finalBlur(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform vec2 uMousePos;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36;vec4 composite(vec2 uv) { vec4 bg = texture(uBgTexture, uv); vec4 fg = texture(uTexture, uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; fg.rgb += dither;vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 st = uv * rot(0.0000 * 2. * PI); pos *= rot(0.0000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float m = 0.4300 * 11. * dist * jawn; return mix(fg, bg, smoothstep(1.0, 0.0, m)); }vec4 getColor(vec2 uv) { return composite(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":0,"downSample":0.25},{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"downSample":0.5},{"prop":"pass","value":3,"includeBg":true}]}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"noiseBlur","usesPingPong":false,"speed":0.01,"animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uResolution;vec4 permute(vec4 t) { return t * (t * 34.0 + 133.0); }vec3 grad(float hash) { vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0; vec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0)); float index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0; cuboct.y *= 1.0 - index1; cuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0); vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad; } vec4 bccNoiseDerivativesPart(vec3 X) { vec3 b = floor(X); vec4 i4 = vec4(X - b, 2.5); vec3 v1 = b + floor(dot(i4, vec4(.25))); vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35))); vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35))); vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35))); vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0)); hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0)); hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0); vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4; vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0); vec4 aa = a * a; vec4 aaaa = aa * aa; vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y); vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w); vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4)); vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) + mat4x3(g1, g2, g3, g4) * aaaa; return vec4(derivative, dot(aaaa, extrapolations)); } vec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) { mat3 orthonormalMap = mat3( 0.788675134594813, -0.211324865405187, -0.577350269189626, -0.211324865405187, 0.788675134594813, -0.577350269189626, 0.577350269189626, 0.577350269189626, 0.577350269189626); X = orthonormalMap * X; vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5); return vec4(result.xyz * orthonormalMap, result.w); }const int MAX_ITERATIONS = 32; const float MAX_ITERATIONS_F = 32.0; const float HALF_ITERATIONS = 16.0;out vec4 fragColor;const float PI = 3.14159265;mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; vec2 noiseUv = rot(0.0000 * -1. * 2.0 * PI) * (uv * vec2(aspectRatio, 1.) - vec2(0.5, 0.5) * vec2(aspectRatio, 1.)) * vec2(0.5000, 1.-0.5000) * 5. * 0.2500; vec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(noiseUv, uTime * 0.025 + 0.0000 * 2.)); vec2 noiseOffset = (noise.xy - 0.5) * (0.8800 + 0.01) * 0.25; vec4 color = vec4(0.0); for (int i = 0; i < MAX_ITERATIONS; i++) { float offset = float(i) - HALF_ITERATIONS; vec2 st = uv + noiseOffset * (offset / MAX_ITERATIONS_F); color += texture(uTexture, st); } color /= MAX_ITERATIONS_F; fragColor = color;}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uResolution;vec4 permute(vec4 t) { return t * (t * 34.0 + 133.0); }vec3 grad(float hash) { vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0; vec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0)); float index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0; cuboct.y *= 1.0 - index1; cuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0); vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad; } vec4 bccNoiseDerivativesPart(vec3 X) { vec3 b = floor(X); vec4 i4 = vec4(X - b, 2.5); vec3 v1 = b + floor(dot(i4, vec4(.25))); vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35))); vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35))); vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35))); vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0)); hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0)); hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0); vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4; vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0); vec4 aa = a * a; vec4 aaaa = aa * aa; vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y); vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w); vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4)); vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) + mat4x3(g1, g2, g3, g4) * aaaa; return vec4(derivative, dot(aaaa, extrapolations)); } vec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) { mat3 orthonormalMap = mat3( 0.788675134594813, -0.211324865405187, -0.577350269189626, -0.211324865405187, 0.788675134594813, -0.577350269189626, 0.577350269189626, 0.577350269189626, 0.577350269189626); X = orthonormalMap * X; vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5); return vec4(result.xyz * orthonormalMap, result.w); }const int MAX_ITERATIONS = 32; const float MAX_ITERATIONS_F = 32.0; const float HALF_ITERATIONS = 16.0;out vec4 fragColor;const float PI = 3.14159265;mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; vec2 noiseUv = rot(0.0000 * -1. * 2.0 * PI) * (uv * vec2(aspectRatio, 1.) - vec2(0.5, 0.5) * vec2(aspectRatio, 1.)) * vec2(0.5000, 1.-0.5000) * 5. * 0.2500; vec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(noiseUv, uTime * 0.025 + 0.0000 * 2.)); vec2 noiseOffset = (noise.xy - 0.5) * (0.8800 + 0.01) * 0.25; vec4 color = vec4(0.0); for (int i = 0; i < MAX_ITERATIONS; i++) { float offset = float(i) - HALF_ITERATIONS; vec2 st = uv + noiseOffset * (offset / MAX_ITERATIONS_F); color += texture(uTexture, st); } color /= MAX_ITERATIONS_F; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5}]}}],"options":{"name":"Autocraft","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.4.20","id":"cBzQNG2AkGiY6qeg8PSa"}
