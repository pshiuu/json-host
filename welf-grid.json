{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"gradient","speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos; vec3 getColor(int index) { switch(index) { case 0: return vec3(0.11372549019607843, 0.11372549019607843, 0.11372549019607843); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0.11372549019607843, 0.11372549019607843, 0.11372549019607843); }void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); uv -= pos; uv /= (0.50*2.); uv = rotate(uv, (0.00 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[{"name":"Desktop","max":null,"min":992,"props":{"scale":0.189,"angle":0,"weight":0.02}},{"name":"Tablet","max":991,"min":576,"props":{"scale":0.306}},{"name":"Mobile","max":575,"min":0,"props":{"scale":0.385}}],"visible":true,"aspectRatio":1,"layerType":"effect","type":"pattern","animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uScale; uniform vec2 uResolution;mat2 rotate2d(float _angle){ return mat2(cos(_angle),-sin(_angle), sin(_angle),cos(_angle)); }float grid(vec2 st, float tile) { float result = 0.; result = fract(st.x) < tile ? 1. : 0.; if(result == 0.) { result += fract(st.y) < tile ? 1. : 0.; } return result; }float stripe(vec2 st, float tile) { return fract(st.x) < tile ? 1. : 0.; }float arrows(vec2 st, float tile) { float s = fract(st.y) < mod(floor(st.x + st.y), 2.) ? st.x : st.y; return mod(floor(s), 2.); }float concentric_circle( vec2 st, float tile ) { return fract(length(st) - tile/2.) < tile ? 1. : 0.; }float circle(vec2 st, float tile) { vec2 gridPos = floor(st); vec2 cellPos = fract(st); return (length(cellPos - 0.5) < tile * 0.5) ? 1. : 0.; }float checkerboard(vec2 st, float tile){ vec2 pos = floor(st); return mod(pos.x+pos.y,2.0); } float wavy_lines(vec2 st, float tile) { float value = sin(st.x * 3.1415926 * 2.0 + st.y * 10.0) * 0.5 + 0.5; return value < tile ? 1. : 0.; } float hexagonal_pattern(vec2 st, float tile) { const float sqrt3 = 1.7320508; vec2 hexSize = vec2(1.0, sqrt3) * tile; vec2 grid = fract(st / hexSize); vec3 grid3 = vec3(grid, grid.y * 0.5); vec3 corner = round(grid3); vec3 v1 = abs(grid3 - corner); vec3 v2 = abs(grid3 + vec3(-0.5, sqrt3 * 0.5, 0.0) - corner); vec3 v3 = abs(grid3 + vec3(0.5, sqrt3 * 0.5, 0.0) - corner); vec3 dist = min(min(v1, v2), v3); return (dist.x + dist.y) < tile * 0.5 ? 1. : 0.; } float diamond_pattern(vec2 st, float tile) { vec2 diamond_coord = abs(st * 2.0); return (diamond_coord.x + diamond_coord.y) < tile ? 1. : 0.; } float spiral_pattern(vec2 st, float tile) { float r = length(st); float theta = atan(st.y, st.x); float spiral = mod(theta + r * 5.0, 3.1415926 * 2.0) - 3.1415926; return abs(spiral) < tile ? 1. : 0.; }out vec4 fragColor; void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);if(bg.a == 0.) { fragColor = vec4(0); return; } vec4 color = vec4(vec3(0.803921568627451, 0.4, 0.4),0.); float aspectRatio = uResolution.x/uResolution.y; float px = (1./1080.); float py = (1./1080.) / aspectRatio; float scl = (40. * uScale); float minpx = min(px, py); float tile = (minpx + 0.02/scl)*scl; tile = round(tile / minpx) * minpx;vec2 st = (uv - vec2(0.5, 0.5)) * scl * vec2(aspectRatio, 1); st = st * rotate2d(0.00 * 360. * 3.1415926 / 180.);if(0 == 0) { color.a = grid(st, tile); } if(0 == 1) { color.a = stripe(st, tile); } if(0 == 2) { color.a = circle(st, tile); } if(0 == 3) { color.a = concentric_circle(st, tile); } if(0 == 4) { color.a = arrows(st, tile); } if(0 == 5) { color.a = checkerboard(st, tile); } if (0 == 6) { color.a = wavy_lines(st, tile); } if (0 == 7) { color.a = hexagonal_pattern(st, tile); } if (0 == 8) { color.a = diamond_pattern(st, tile); } if (0 == 9) { color.a = spiral_pattern(st, tile); } fragColor = mix(bg, color, color.a); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{"scale":{"name":"uScale","type":"1f","value":0}}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"ripple","speed":0.5,"trackMouse":1,"mouseMomentum":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uResolution;out vec4 fragColor;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + vVertexPosition.z * 2.; vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }void main() { vec2 uv = vVertexPosition.xy + 0.5; uv = perspectiveUV(uv); vec4 color = texture(uTexture, uv); fragColor = color; ; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float; in vec3 aVertexPosition; in vec2 aTextureCoord; uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec3 vVertexPosition; out vec2 vTextureCoord;uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t * t; }void main() { vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1); float freq = 0.50 * 50.; vec3 vertexPosition = aVertexPosition * 0.5; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), uMousePos - 0.5, 1.00); float dist = length((vertexPosition.xy) * aspectRatio - (pos - 0.5) * aspectRatio); float easeDist = max(0.,1. - dist - (1. - 0.31));float easeFactor = ease(1, easeDist); float strength = 0.50 * 0.2 * easeFactor;float wave = sin(dist * freq - uTime * 0.05) * strength; vertexPosition = vertexPosition + normalize(vertexPosition + vec3(1.-pos - 0.5, 0)) * wave; vertexPosition.z = wave; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);vTextureCoord = aTextureCoord; vVertexPosition = vertexPosition; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"mouse","animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;const float PI = 3.1415926; const float ITERATIONS = 24.0;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec4 defaultTrail(vec2 uv, vec2 mouseDir) { vec4 color = vec4(0); vec2 distorted = mouseDir * 0.4; color = texture(uTexture, uv - distorted); color.rgb = chromatic_aberration(color.rgb, uv - distorted, distorted * 0.00 * 0.12); return color; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float aspectRatio = uResolution.x / uResolution.y;return defaultTrail(uv, mouseDir); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.12 * 2.0); vec2 direction = angleToDir(angle); vec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, strength);fragColor = color; }","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 uv = vTextureCoord; vec2 correctedUv = uv * vec2(aspectRatio, 1.0);vec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0); float dist = length(dir); dir = normalize(dir);float rad = 0.16 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI;float t = clamp(dot(correctedUv - uPreviousMousePos * vec2(aspectRatio, 1.0), dir) / dist, 0.0, 1.0); vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * vec2(aspectRatio, 1.0); float distanceToLine = distance(correctedUv, closestPoint);float s = smoothstep(rad, rad * 0.00, distanceToLine);vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 mouseColor = hsv2rgb(color);vec3 lastFrameColor = texture(uPingPongTexture, mix(uv, uv / 1.03 + 0.015, 0.00)).rgb; vec3 draw = mix(lastFrameColor, mouseColor, min(1.0, dist * s));fragColor = vec4(draw * pow(0.50, 0.1), 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{}}}],"options":{"name":"Welf GRID","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false,"freePlan":false},"version":"1.3.2","id":"XrLPc2PhsODbWulmSw9g"}
